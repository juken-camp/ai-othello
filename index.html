<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ULTIMATE AI OTHELLO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: "Fredoka", sans-serif;
            margin: 0;
            padding: 15px;
            background: #faf8ef;
            color: #776e65;
            text-align: center;
            min-height: 100vh;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        .heading {
            font-size: 42px;
            font-weight: 700;
            margin: 0 0 15px 0;
            color: #776e65;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            letter-spacing: 2px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            gap: 8px;
        }

        .info-card {
            background: #bbada0;
            padding: 10px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            text-align: center;
            flex: 1;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .info-label {
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .info-value {
            font-size: 18px;
            font-weight: 700;
        }

        .ai-status {
            color: #8f7a66;
            padding: 10px 0;
            margin: 10px 0;
            font-weight: 500;
            font-size: 13px;
        }

        .current-player {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            padding: 12px;
            border-radius: 12px;
            margin: 15px 0;
            color: white;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        .current-player.ai-turn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .game-board {
            background: #bbada0;
            border-radius: 16px;
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            display: inline-block;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #8f7a66;
            padding: 12px;
            border-radius: 12px;
        }

        .cell {
            width: 45px;
            height: 45px;
            background: #2d5016;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .cell:hover {
            background: #3a6b1c;
            transform: scale(1.05);
        }

        .cell.valid-move {
            background: #4a7c59;
            box-shadow: 0 0 10px rgba(106, 168, 79, 0.6);
            animation: validPulse 1.5s ease-in-out infinite;
        }

        .cell.valid-move:hover {
            background: #5d9b69;
        }

        .cell.corner {
            background: #4a4a4a;
        }

        .cell.edge {
            background: #3a3a3a;
        }

        @keyframes validPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(106, 168, 79, 0.6); }
            50% { box-shadow: 0 0 20px rgba(106, 168, 79, 1); }
        }

        .stone {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }

        .stone.black {
            background: radial-gradient(circle at 30% 30%, #2c3e50, #1a252f);
            border: 2px solid #34495e;
        }

        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ecf0f1, #bdc3c7);
            border: 2px solid #95a5a6;
        }

        .stone.placing {
            animation: placePiece 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .stone.flipping {
            animation: flipPiece 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes placePiece {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(180deg);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(90deg);
            }
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes flipPiece {
            0% { transform: translate(-50%, -50%) rotateY(0deg) scale(1); }
            50% { transform: translate(-50%, -50%) rotateY(90deg) scale(1.1); }
            100% { transform: translate(-50%, -50%) rotateY(180deg) scale(1); }
        }

        .ai-thinking {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 12px 15px;
            border-radius: 12px;
            margin: 12px 0;
            font-weight: 600;
            animation: thinking 1.5s ease-in-out infinite;
            font-size: 13px;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #8f7a66, #9f8977);
            border: none;
            color: #f9f6f2;
            padding: 10px 16px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        }

        .btn.new-game {
            background: linear-gradient(135deg, #edcf72, #edc850);
            color: #776e65;
        }

        .btn.pass {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            display: none;
        }

        .btn.difficulty {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
        }

        .game-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .message-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 350px;
            width: 90%;
        }

        .message-content h2 {
            font-size: 28px;
            margin: 0 0 15px 0;
            color: #776e65;
        }

        .message-content p {
            font-size: 16px;
            margin-bottom: 25px;
            color: #8f7a66;
            line-height: 1.4;
        }

        .message-content button {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
        }

        /* „É¢„Éê„Ç§„É´ÂØæÂøú */
        @media (max-width: 520px) {
            .container {
                margin: 0 5px;
            }
            
            .heading {
                font-size: 32px;
                margin-bottom: 10px;
            }
            
            .cell {
                width: 38px;
                height: 38px;
            }
            
            .stone {
                width: 30px;
                height: 30px;
            }
            
            .game-board {
                padding: 12px;
            }
            
            .board {
                gap: 2px;
                padding: 10px;
            }

            .info-value {
                font-size: 16px;
            }

            .info-label {
                font-size: 10px;
            }

            .controls {
                gap: 8px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 12px;
            }

            .current-player {
                font-size: 14px;
                padding: 10px;
            }

            .ai-status {
                font-size: 12px;
            }

            .ai-thinking {
                font-size: 12px;
                padding: 10px 12px;
            }
        }

        @media (max-width: 400px) {
            .cell {
                width: 32px;
                height: 32px;
            }
            
            .stone {
                width: 26px;
                height: 26px;
            }

            .heading {
                font-size: 28px;
            }

            .game-info {
                gap: 6px;
            }

            .info-card {
                padding: 8px;
            }

            .info-value {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="heading">ULTIMATE AI</h1>

        <div class="game-info">
            <div class="info-card">
                <div class="info-label">„ÅÇ„Å™„Åü ‚ö´</div>
                <div class="info-value" id="human-score">2</div>
            </div>
            <div class="info-card">
                <div class="info-label">AI ‚ö™</div>
                <div class="info-value" id="ai-score">2</div>
            </div>
            <div class="info-card">
                <div class="info-label">ÂãùÂà©Êï∞</div>
                <div class="info-value" id="wins">0</div>
            </div>
            <div class="info-card">
                <div class="info-label">„É¨„Éô„É´</div>
                <div class="info-value" id="difficulty">Á•û</div>
            </div>
        </div>

        <div class="ai-status" id="ai-status">
            üß† AIÁä∂ÊÖã: ÂæÖÊ©ü‰∏≠ | Êé¢Á¥¢Ê∑±Â∫¶: Ëá™ÂãïË™øÊï¥ | Ë©ï‰æ°Èñ¢Êï∞: Ultimate
        </div>

        <div class="current-player" id="current-player">
            ‚ö´ „ÅÇ„Å™„Åü„ÅÆÁï™„Åß„Åô
        </div>

        <div id="ai-thinking" class="ai-thinking" style="display: none;">
            ü§ñ Ultimate AI ÊÄùËÄÉ‰∏≠...<br>
            <span id="thinking-detail">ÂÆåÁíßÊâã„ÇíË®àÁÆó‰∏≠...</span>
        </div>

        <div class="game-board">
            <div class="board" id="board">
                <!-- „Éú„Éº„Éâ„ÅØÂãïÁöÑ„Å´ÁîüÊàê -->
            </div>
        </div>

        <div class="controls">
            <button class="btn pass" id="pass-btn" onclick="passMove()">„Éë„Çπ</button>
            <button class="btn new-game" onclick="newGame()">Êñ∞„Ç≤„Éº„É†</button>
            <button class="btn difficulty" onclick="changeDifficulty()">Èõ£ÊòìÂ∫¶Â§âÊõ¥</button>
            <button class="btn" onclick="resetStats()">Ë®òÈå≤„É™„Çª„ÉÉ„Éà</button>
        </div>
    </div>

    <!-- „Ç≤„Éº„É†ÁµÇ‰∫Ü„É°„ÉÉ„Çª„Éº„Ç∏ -->
    <div class="game-message" id="game-message">
        <div class="message-content">
            <h2 id="message-title">„Ç≤„Éº„É†ÁµÇ‰∫Ü</h2>
            <p id="message-text">„ÅäÁñ≤„Çå„Åï„Åæ„Åß„Åó„ÅüÔºÅ</p>
            <button onclick="hideMessage()">Á∂ö„Åë„Çã</button>
        </div>
    </div>

    <script>
        // ÂäπÊûúÈü≥„Ç∑„Çπ„ÉÜ„É†
        const SoundSystem = {
            context: null,
            
            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            },

            playTone(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0, this.context.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, this.context.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + duration);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + duration);
            },

            place() { this.playTone(800, 0.1, 'sine', 0.25); },
            flip() { this.playTone(600, 0.15, 'triangle', 0.2); },
            win() {
                this.playTone(523, 0.2, 'sine', 0.4);
                setTimeout(() => this.playTone(659, 0.2, 'sine', 0.4), 200);
                setTimeout(() => this.playTone(784, 0.3, 'sine', 0.4), 400);
            },
            lose() {
                this.playTone(330, 0.3, 'sine', 0.3);
                setTimeout(() => this.playTone(294, 0.3, 'sine', 0.3), 150);
                setTimeout(() => this.playTone(262, 0.5, 'sine', 0.3), 300);
            }
        };

        // „Ç≤„Éº„É†ÂÆöÊï∞
        const EMPTY = 0;
        const HUMAN = 1;
        const AI = 2;

        // ÊñπÂêëÂÆöÁæ©Ôºà8ÊñπÂêëÔºâ
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        // Èõ£ÊòìÂ∫¶Ë®≠ÂÆö
        const difficulties = {
            easy: { name: 'ÂàùÁ¥ö', depth: 4, description: 'ÂàùÂøÉËÄÖÂêë„Åë' },
            normal: { name: '‰∏≠Á¥ö', depth: 6, description: 'Ê®ôÊ∫ñÁöÑ„Å™Âº∑„Åï' },
            hard: { name: '‰∏äÁ¥ö', depth: 8, description: 'ÊâãÂº∑„ÅÑÁõ∏Êâã' },
            expert: { name: 'ÊúÄÂº∑', depth: 10, description: 'Â∞ÇÈñÄÂÆ∂„É¨„Éô„É´' },
            ultimate: { name: 'Á•û', depth: 12, description: 'Á©∂Ê•µ„ÅÆAI' }
        };

        // „Ç≤„Éº„É†Áä∂ÊÖã
        let board = [];
        let currentPlayer = HUMAN;
        let gameActive = true;
        let wins = parseInt(localStorage.getItem('ultimateOthelloWins')) || 0;
        let currentDifficulty = localStorage.getItem('othelloDifficulty') || 'ultimate';
        let transpositionTable = new Map();
        let nodesEvaluated = 0;

        // Á©∂Ê•µ„ÅÆ‰ΩçÁΩÆË©ï‰æ°„ÉÜ„Éº„Éñ„É´
        const ultimatePositionValues = [
            [1000, -300,  100,   80,   80,  100, -300, 1000],
            [-300, -500,  -50,  -50,  -50,  -50, -500, -300],
            [ 100,  -50,   50,   10,   10,   50,  -50,  100],
            [  80,  -50,   10,    5,    5,   10,  -50,   80],
            [  80,  -50,   10,    5,    5,   10,  -50,   80],
            [ 100,  -50,   50,   10,   10,   50,  -50,  100],
            [-300, -500,  -50,  -50,  -50,  -50, -500, -300],
            [1000, -300,  100,   80,   80,  100, -300, 1000]
        ];

        // „Ç®„ÉÉ„Ç∏„Å®„Ç≥„Éº„Éä„Éº„ÅÆÂÆöÁæ©
        const corners = [[0,0], [0,7], [7,0], [7,7]];
        const edges = [];
        for (let i = 0; i < 8; i++) {
            edges.push([0, i], [7, i], [i, 0], [i, 7]);
        }

        // Âç±Èô∫„Å™X‰ΩçÁΩÆÔºà„Ç≥„Éº„Éä„ÉºÈö£Êé•Ôºâ
        const xSquares = [[1,1], [1,6], [6,1], [6,6]];

        // ÂàùÊúüÂåñ
        function init() {
            SoundSystem.init();
            createBoard();
            newGame();
            updateWins();
            updateDifficultyDisplay();
        }

        // „Éú„Éº„Éâ‰ΩúÊàê
        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            board = Array(8).fill().map(() => Array(8).fill(EMPTY));
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    // ÁâπÂà•„Å™‰ΩçÁΩÆ„ÅÆ„Çπ„Çø„Ç§„É´
                    if (corners.some(([r, c]) => r === row && c === col)) {
                        cell.classList.add('corner');
                    } else if (edges.some(([r, c]) => r === row && c === col)) {
                        cell.classList.add('edge');
                    }
                    
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', () => makeMove(row, col));
                    boardElement.appendChild(cell);
                }
            }
        }

        // Êñ∞„Åó„ÅÑ„Ç≤„Éº„É†
        function newGame() {
            board = Array(8).fill().map(() => Array(8).fill(EMPTY));
            currentPlayer = HUMAN;
            gameActive = true;
            transpositionTable.clear();
            
            // ÂàùÊúüÈÖçÁΩÆ
            board[3][3] = AI;
            board[3][4] = HUMAN;
            board[4][3] = HUMAN;
            board[4][4] = AI;
            
            updateDisplay();
            updateCurrentPlayer();
            updateAIStatus('ÂæÖÊ©ü‰∏≠', 0, 'Ultimate');
            document.getElementById('pass-btn').style.display = 'none';
        }

        // „Éó„É¨„Ç§„É§„Éº„ÅÆÊâã
        function makeMove(row, col) {
            if (!gameActive || currentPlayer !== HUMAN) return;
            if (!isValidMove(row, col, HUMAN)) return;
            
            executeMove(row, col, HUMAN);
            SoundSystem.place();
            
            setTimeout(() => {
                if (gameActive) {
                    currentPlayer = AI;
                    updateCurrentPlayer();
                    aiMove();
                }
            }, 800);
        }

        // Êâã„ÇíÂÆüË°å
        function executeMove(row, col, player) {
            board[row][col] = player;
            const flips = getFlips(row, col, player);
            
            addStone(row, col, player);
            
            setTimeout(() => {
                flips.forEach(([r, c], index) => {
                    setTimeout(() => {
                        board[r][c] = player;
                        flipStone(r, c, player);
                        SoundSystem.flip();
                    }, index * 100);
                });
            }, 300);
            
            setTimeout(() => {
                updateDisplay();
                checkGameEnd();
            }, 300 + flips.length * 100);
        }

        // AI „ÅÆÊâã
        function aiMove() {
            document.getElementById('ai-thinking').style.display = 'block';
            updateThinkingDetail('AIÊÄùËÄÉÈñãÂßã...');
            
            const startTime = Date.now();
            let thinkingTime = 1500 + Math.random() * 2000;
            
            setTimeout(() => {
                const validMoves = getValidMoves(AI);
                
                if (validMoves.length === 0) {
                    document.getElementById('ai-thinking').style.display = 'none';
                    currentPlayer = HUMAN;
                    updateCurrentPlayer();
                    
                    if (getValidMoves(HUMAN).length === 0) {
                        endGame();
                    }
                    return;
                }
                
                nodesEvaluated = 0;
                const bestMove = getUltimateBestMove();
                const endTime = Date.now();
                
                updateAIStatus('ÂÆå‰∫Ü', nodesEvaluated, `${endTime - startTime}ms`);
                
                executeMove(bestMove[0], bestMove[1], AI);
                SoundSystem.place();
                
                document.getElementById('ai-thinking').style.display = 'none';
                
                setTimeout(() => {
                    if (gameActive) {
                        currentPlayer = HUMAN;
                        updateCurrentPlayer();
                    }
                }, 800);
            }, thinkingTime);
        }

        // Á©∂Ê•µ„ÅÆAI: ÊúÄÈÅ©Êâã„ÇíÂèñÂæó
        function getUltimateBestMove() {
            const gamePhase = getGamePhase();
            const depth = getOptimalDepth(gamePhase);
            
            updateThinkingDetail(`${gamePhase}Êà¶Áï• | Ê∑±Â∫¶${depth}„ÅßÂÆåÁíßÊâãË®àÁÆó‰∏≠...`);
            
            let bestScore = -Infinity;
            let bestMove = null;
            const validMoves = getValidMoves(AI);
            
            // Êâã„ÇíÈáçË¶ÅÂ∫¶È†Ü„Å´„ÇΩ„Éº„Éà
            const sortedMoves = sortMovesByPriority(validMoves, AI);
            
            for (const [row, col] of sortedMoves) {
                const boardCopy = copyBoard();
                const flips = getFlips(row, col, AI);
                
                boardCopy[row][col] = AI;
                flips.forEach(([r, c]) => boardCopy[r][c] = AI);
                
                const score = ultimateMinimax(boardCopy, depth - 1, -Infinity, Infinity, false, gamePhase);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = [row, col];
                }
            }
            
            return bestMove || validMoves[0];
        }

        // Á©∂Ê•µ„ÅÆ„Éü„Éã„Éû„ÉÉ„ÇØ„ÇπÊ≥ï
        function ultimateMinimax(boardState, depth, alpha, beta, isMaximizing, gamePhase) {
            nodesEvaluated++;
            
            // ÁµÇÁ´ØÊù°‰ª∂
            if (depth === 0) {
                return ultimateEvaluateBoard(boardState, gamePhase);
            }
            
            // „Éà„É©„É≥„Çπ„Éù„Ç∏„Ç∑„Éß„É≥„ÉÜ„Éº„Éñ„É´„ÉÅ„Çß„ÉÉ„ÇØ
            const boardHash = getBoardHash(boardState);
            const tableKey = `${boardHash}_${depth}_${isMaximizing}`;
            if (transpositionTable.has(tableKey)) {
                return transpositionTable.get(tableKey);
            }
            
            const player = isMaximizing ? AI : HUMAN;
            const validMoves = getValidMovesForBoard(boardState, player);
            
            if (validMoves.length === 0) {
                const opponent = 3 - player;
                const opponentMoves = getValidMovesForBoard(boardState, opponent);
                if (opponentMoves.length === 0) {
                    const result = ultimateEvaluateFinalBoard(boardState);
                    transpositionTable.set(tableKey, result);
                    return result;
                }
                const result = ultimateMinimax(boardState, depth - 1, alpha, beta, !isMaximizing, gamePhase);
                transpositionTable.set(tableKey, result);
                return result;
            }
            
            // Êâã„Çí„ÇΩ„Éº„Éà
            const sortedMoves = sortMovesByPriority(validMoves, player);
            
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const [row, col] of sortedMoves) {
                    const newBoard = copyBoard(boardState);
                    const flips = getFlipsForBoard(newBoard, row, col, player);
                    newBoard[row][col] = player;
                    flips.forEach(([r, c]) => newBoard[r][c] = player);
                    
                    const eval = ultimateMinimax(newBoard, depth - 1, alpha, beta, false, gamePhase);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    
                    if (beta <= alpha) break;
                }
                transpositionTable.set(tableKey, maxEval);
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const [row, col] of sortedMoves) {
                    const newBoard = copyBoard(boardState);
                    const flips = getFlipsForBoard(newBoard, row, col, player);
                    newBoard[row][col] = player;
                    flips.forEach(([r, c]) => newBoard[r][c] = player);
                    
                    const eval = ultimateMinimax(newBoard, depth - 1, alpha, beta, true, gamePhase);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    
                    if (beta <= alpha) break;
                }
                transpositionTable.set(tableKey, minEval);
                return minEval;
            }
        }

        // Á©∂Ê•µ„ÅÆ„Éú„Éº„ÉâË©ï‰æ°Èñ¢Êï∞
        function ultimateEvaluateBoard(boardState, gamePhase) {
            let score = 0;
            
            // Âü∫Êú¨ÁöÑ„Å™‰ΩçÁΩÆË©ï‰æ°
            score += evaluatePositions(boardState);
            
            // „Ç≥„Éº„Éä„ÉºÂà∂Âæ°Ë©ï‰æ°
            score += evaluateCorners(boardState) * 500;
            
            // „Ç®„ÉÉ„Ç∏Âà∂Âæ°Ë©ï‰æ°
            score += evaluateEdges(boardState) * 100;
            
            // Ê©üÂãïÂäõË©ï‰æ°
            score += evaluateMobility(boardState, gamePhase);
            
            // ÂÆâÂÆöÊÄßË©ï‰æ°
            score += evaluateStability(boardState) * 200;
            
            // „Ç≤„Éº„É†ÊÆµÈöéÂà•ÁâπÂà•Ë©ï‰æ°
            if (gamePhase === 'Â∫èÁõ§') {
                score += evaluateOpeningStrategy(boardState);
            } else if (gamePhase === 'ÁµÇÁõ§') {
                score += evaluateEndgameStrategy(boardState);
            }
            
            // „Éë„É™„ÉÜ„Ç£Ë©ï‰æ°ÔºàÁµÇÁõ§ÈáçË¶ÅÔºâ
            if (gamePhase === 'ÁµÇÁõ§') {
                score += evaluateParity(boardState) * 50;
            }
            
            return score;
        }

        // ‰ΩçÁΩÆË©ï‰æ°
        function evaluatePositions(boardState) {
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === AI) {
                        score += ultimatePositionValues[row][col];
                    } else if (boardState[row][col] === HUMAN) {
                        score -= ultimatePositionValues[row][col];
                    }
                }
            }
            return score;
        }

        // „Ç≥„Éº„Éä„ÉºÂà∂Âæ°Ë©ï‰æ°
        function evaluateCorners(boardState) {
            let score = 0;
            for (const [row, col] of corners) {
                if (boardState[row][col] === AI) score += 1;
                else if (boardState[row][col] === HUMAN) score -= 1;
            }
            return score;
        }

        // „Ç®„ÉÉ„Ç∏Âà∂Âæ°Ë©ï‰æ°
        function evaluateEdges(boardState) {
            let score = 0;
            for (const [row, col] of edges) {
                if (boardState[row][col] === AI) score += 1;
                else if (boardState[row][col] === HUMAN) score -= 1;
            }
            return score;
        }

        // Ê©üÂãïÂäõË©ï‰æ°
        function evaluateMobility(boardState, gamePhase) {
            const aiMoves = getValidMovesForBoard(boardState, AI).length;
            const humanMoves = getValidMovesForBoard(boardState, HUMAN).length;
            
            const mobilityWeight = gamePhase === 'Â∫èÁõ§' ? 50 : gamePhase === '‰∏≠Áõ§' ? 30 : 10;
            return (aiMoves - humanMoves) * mobilityWeight;
        }

        // ÂÆâÂÆöÊÄßË©ï‰æ°ÔºàÁ¢∫ÂÆöÁü≥Ôºâ
        function evaluateStability(boardState) {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] !== EMPTY) {
                        const stability = calculateStability(boardState, row, col);
                        if (boardState[row][col] === AI) {
                            score += stability;
                        } else {
                            score -= stability;
                        }
                    }
                }
            }
            
            return score;
        }

        // ÂÆâÂÆöÊÄßË®àÁÆó
        function calculateStability(boardState, row, col) {
            const player = boardState[row][col];
            if (player === EMPTY) return 0;
            
            // „Ç≥„Éº„Éä„Éº„ÅØÂ∏∏„Å´ÂÆâÂÆö
            if (corners.some(([r, c]) => r === row && c === col)) {
                return 10;
            }
            
            let stability = 0;
            
            // ÂêÑÊñπÂêë„ÅÆÂÆâÂÆöÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            for (const [dr, dc] of directions) {
                if (isDirectionStable(boardState, row, col, dr, dc, player)) {
                    stability += 1;
                }
            }
            
            return stability;
        }

        // ÊñπÂêë„ÅÆÂÆâÂÆöÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
        function isDirectionStable(boardState, row, col, dr, dc, player) {
            // ‰∏ÄÊñπÂêë„Å´ÂÆâÂÆö„Åó„Å¶„ÅÑ„ÇãÁü≥„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            let r1 = row + dr, c1 = col + dc;
            let r2 = row - dr, c2 = col - dc;
            
            let stable1 = false, stable2 = false;
            
            // Ê≠£ÊñπÂêë„ÉÅ„Çß„ÉÉ„ÇØ
            while (r1 >= 0 && r1 < 8 && c1 >= 0 && c1 < 8) {
                if (boardState[r1][c1] === player) {
                    if (corners.some(([r, c]) => r === r1 && c === c1)) {
                        stable1 = true;
                        break;
                    }
                } else {
                    break;
                }
                r1 += dr;
                c1 += dc;
            }
            
            // Ë≤†ÊñπÂêë„ÉÅ„Çß„ÉÉ„ÇØ
            while (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
                if (boardState[r2][c2] === player) {
                    if (corners.some(([r, c]) => r === r2 && c === c2)) {
                        stable2 = true;
                        break;
                    }
                } else {
                    break;
                }
                r2 -= dr;
                c2 -= dc;
            }
            
            return stable1 || stable2;
        }

        // Â∫èÁõ§Êà¶Áï•Ë©ï‰æ°
        function evaluateOpeningStrategy(boardState) {
            let score = 0;
            
            // X‰ΩçÁΩÆÔºà„Ç≥„Éº„Éä„ÉºÈö£Êé•Ôºâ„ÅÆÂõûÈÅø
            for (const [row, col] of xSquares) {
                if (boardState[row][col] === AI) score -= 200;
                else if (boardState[row][col] === HUMAN) score += 200;
            }
            
            // ‰∏≠Â§ÆÂà∂Âæ°
            const centerSquares = [[3,3], [3,4], [4,3], [4,4]];
            for (const [row, col] of centerSquares) {
                if (boardState[row][col] === AI) score += 20;
                else if (boardState[row][col] === HUMAN) score -= 20;
            }
            
            return score;
        }

        // ÁµÇÁõ§Êà¶Áï•Ë©ï‰æ°
        function evaluateEndgameStrategy(boardState) {
            let aiStones = 0;
            let humanStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === AI) aiStones++;
                    else if (boardState[row][col] === HUMAN) humanStones++;
                }
            }
            
            // ÁµÇÁõ§„Åß„ÅØÁü≥Êï∞„ÅåÈáçË¶Å
            return (aiStones - humanStones) * 100;
        }

        // „Éë„É™„ÉÜ„Ç£Ë©ï‰æ°
        function evaluateParity(boardState) {
            const emptyCount = countEmpty(boardState);
            return emptyCount % 2 === 0 ? 1 : -1; // ÂÅ∂Êï∞„Å™„ÇâÊúâÂà©
        }

        // Êâã„ÅÆÂÑ™ÂÖàÂ∫¶„ÇΩ„Éº„Éà
        function sortMovesByPriority(moves, player) {
            return moves.sort((a, b) => {
                const scoreA = getMoveScore(a, player);
                const scoreB = getMoveScore(b, player);
                return scoreB - scoreA;
            });
        }

        // Êâã„ÅÆ„Çπ„Ç≥„Ç¢Ë®àÁÆó
        function getMoveScore(move, player) {
            const [row, col] = move;
            let score = 0;
            
            // ‰ΩçÁΩÆ‰æ°ÂÄ§
            score += ultimatePositionValues[row][col];
            
            // „Ç≥„Éº„Éä„Éº„Å™„ÇâÊúÄÈ´òÁÇπ
            if (corners.some(([r, c]) => r === row && c === col)) {
                score += 10000;
            }
            
            // „Å≤„Å£„Åè„ÇäËøî„ÇãÁü≥„ÅÆÊï∞
            const flips = getFlipsForBoard(board, row, col, player);
            score += flips.length * 10;
            
            return score;
        }

        // „Ç≤„Éº„É†ÊÆµÈöéÂà§ÂÆö
        function getGamePhase() {
            const totalStones = countTotalStones();
            if (totalStones <= 20) return 'Â∫èÁõ§';
            if (totalStones >= 50) return 'ÁµÇÁõ§';
            return '‰∏≠Áõ§';
        }

        // ÊúÄÈÅ©Ê∑±Â∫¶ÂèñÂæó
        function getOptimalDepth(gamePhase) {
            const baseDepth = difficulties[currentDifficulty].depth;
            const emptyCount = countEmpty();
            
            if (gamePhase === 'ÁµÇÁõ§' && emptyCount <= 12) {
                return Math.min(emptyCount, baseDepth + 2);
            }
            
            return baseDepth;
        }

        // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞
        function countTotalStones() {
            let count = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] !== EMPTY) count++;
                }
            }
            return count;
        }

        function countEmpty(boardState = board) {
            let count = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === EMPTY) count++;
                }
            }
            return count;
        }

        function getBoardHash(boardState) {
            return boardState.flat().join('');
        }

        // Âü∫Êú¨„Ç≤„Éº„É†Èñ¢Êï∞
        function isValidMove(row, col, player) {
            if (board[row][col] !== EMPTY) return false;
            return getFlips(row, col, player).length > 0;
        }

        function getFlips(row, col, player) {
            const flips = [];
            const opponent = 3 - player;
            
            for (const [dr, dc] of directions) {
                const lineFlips = [];
                let r = row + dr;
                let c = col + dc;
                
                while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
                    lineFlips.push([r, c]);
                    r += dr;
                    c += dc;
                }
                
                if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player && lineFlips.length > 0) {
                    flips.push(...lineFlips);
                }
            }
            
            return flips;
        }

        function getValidMoves(player) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidMove(row, col, player)) {
                        moves.push([row, col]);
                    }
                }
            }
            return moves;
        }

        function getValidMovesForBoard(boardState, player) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === EMPTY && getFlipsForBoard(boardState, row, col, player).length > 0) {
                        moves.push([row, col]);
                    }
                }
            }
            return moves;
        }

        function getFlipsForBoard(boardState, row, col, player) {
            const flips = [];
            const opponent = 3 - player;
            
            for (const [dr, dc] of directions) {
                const lineFlips = [];
                let r = row + dr;
                let c = col + dc;
                
                while (r >= 0 && r < 8 && c >= 0 && c < 8 && boardState[r][c] === opponent) {
                    lineFlips.push([r, c]);
                    r += dr;
                    c += dc;
                }
                
                if (r >= 0 && r < 8 && c >= 0 && c < 8 && boardState[r][c] === player && lineFlips.length > 0) {
                    flips.push(...lineFlips);
                }
            }
            
            return flips;
        }

        function copyBoard(boardState = board) {
            return boardState.map(row => [...row]);
        }

        function ultimateEvaluateFinalBoard(boardState) {
            let aiStones = 0;
            let humanStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === AI) aiStones++;
                    else if (boardState[row][col] === HUMAN) humanStones++;
                }
            }
            
            if (aiStones > humanStones) return 100000;
            if (humanStones > aiStones) return -100000;
            return 0;
        }

        // UIÊõ¥Êñ∞Èñ¢Êï∞
        function addStone(row, col, player) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const stone = document.createElement('div');
            stone.className = `stone ${player === HUMAN ? 'black' : 'white'} placing`;
            cell.appendChild(stone);
        }

        function flipStone(row, col, player) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const stone = cell.querySelector('.stone');
            if (stone) {
                stone.classList.add('flipping');
                setTimeout(() => {
                    stone.className = `stone ${player === HUMAN ? 'black' : 'white'}`;
                }, 300);
            }
        }

        function updateDisplay() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('valid-move');
            });
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (board[row][col] !== EMPTY) {
                        const stone = document.createElement('div');
                        stone.className = `stone ${board[row][col] === HUMAN ? 'black' : 'white'}`;
                        cell.appendChild(stone);
                    }
                }
            }
            
            if (currentPlayer === HUMAN && gameActive) {
                const validMoves = getValidMoves(HUMAN);
                validMoves.forEach(([row, col]) => {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    cell.classList.add('valid-move');
                });
            }
            
            let humanStones = 0;
            let aiStones = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === HUMAN) humanStones++;
                    else if (board[row][col] === AI) aiStones++;
                }
            }
            
            document.getElementById('human-score').textContent = humanStones;
            document.getElementById('ai-score').textContent = aiStones;
        }

        function updateCurrentPlayer() {
            const element = document.getElementById('current-player');
            if (currentPlayer === HUMAN) {
                element.textContent = '‚ö´ „ÅÇ„Å™„Åü„ÅÆÁï™„Åß„Åô';
                element.className = 'current-player';
            } else {
                element.textContent = '‚ö™ Ultimate AI„ÅÆÁï™„Åß„Åô';
                element.className = 'current-player ai-turn';
            }
        }

        function updateAIStatus(status, nodes, extra) {
            const element = document.getElementById('ai-status');
            element.innerHTML = `üß† AIÁä∂ÊÖã: ${status} | Êé¢Á¥¢„Éé„Éº„Éâ: ${nodes.toLocaleString()} | ${extra}`;
        }

        function updateThinkingDetail(text) {
            document.getElementById('thinking-detail').textContent = text;
        }

        function updateDifficultyDisplay() {
            document.getElementById('difficulty').textContent = difficulties[currentDifficulty].name;
        }

        function updateWins() {
            document.getElementById('wins').textContent = wins;
        }

        // „Ç≤„Éº„É†Âà∂Âæ°Èñ¢Êï∞
        function passMove() {
            if (!gameActive || currentPlayer !== HUMAN) return;
            
            currentPlayer = AI;
            updateCurrentPlayer();
            aiMove();
        }

        function checkGameEnd() {
            const humanMoves = getValidMoves(HUMAN);
            const aiMoves = getValidMoves(AI);
            
            if (humanMoves.length === 0 && aiMoves.length === 0) {
                endGame();
                return;
            }
            
            if (humanMoves.length === 0) {
                document.getElementById('pass-btn').style.display = 'inline-block';
            } else {
                document.getElementById('pass-btn').style.display = 'none';
            }
        }

        function endGame() {
            gameActive = false;
            
            let humanStones = 0;
            let aiStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === HUMAN) humanStones++;
                    else if (board[row][col] === AI) aiStones++;
                }
            }
            
            let title, text;
            if (humanStones > aiStones) {
                title = 'üèÜ Â•áË∑°ÔºÅUltimate AI„Å´ÂãùÂà©ÔºÅ';
                text = `${humanStones} vs ${aiStones} „Åß„ÅÇ„Å™„Åü„ÅÆÂãù„Å°ÔºÅ\n\n‰∏ñÁïåÊúÄÂº∑„É¨„Éô„É´„ÅÆAI„Å´Âãù„Å§„Å™„Çì„Å¶...\n„ÅÇ„Å™„Åü„ÅØÁúü„ÅÆÂ§©Êâç„Åß„ÅôÔºÅ\n\n${difficulties[currentDifficulty].description}„Å´ÂãùÂà©„Åó„Åæ„Åó„ÅüÔºÅ`;
                wins++;
                localStorage.setItem('ultimateOthelloWins', wins);
                SoundSystem.win();
            } else if (aiStones > humanStones) {
                title = 'ü§ñ Ultimate AI„ÅÆÂãùÂà©';
                text = `${aiStones} vs ${humanStones} „ÅßAI„ÅÆÂãù„Å°\n\n${getGamePhase()}„Åæ„Åß${nodesEvaluated.toLocaleString()}Êâã„ÇíËß£Êûê\nÁ©∂Ê•µ„ÅÆ„Ç¢„É´„Ç¥„É™„Ç∫„É†„Å´ÊïóÂåó...`;
                SoundSystem.lose();
            } else {
                title = 'ü§ù ‰∫íËßí„ÅÆÂãùË≤†ÔºÅ';
                text = `${humanStones} vs ${aiStones} „ÅßÂºï„ÅçÂàÜ„Åë\n\nUltimate AI„Å®Âºï„ÅçÂàÜ„Åë„Å®„ÅØ\nÁ¥†Êô¥„Çâ„Åó„ÅÑÂÆüÂäõ„Åß„ÅôÔºÅ`;
            }
            
            updateWins();
            setTimeout(() => showMessage(title, text), 1000);
        }

        function changeDifficulty() {
            const keys = Object.keys(difficulties);
            const currentIndex = keys.indexOf(currentDifficulty);
            const nextIndex = (currentIndex + 1) % keys.length;
            currentDifficulty = keys[nextIndex];
            
            localStorage.setItem('othelloDifficulty', currentDifficulty);
            updateDifficultyDisplay();
            transpositionTable.clear();
            
            showMessage(
                `Èõ£ÊòìÂ∫¶Â§âÊõ¥: ${difficulties[currentDifficulty].name}`,
                `${difficulties[currentDifficulty].description}\nÊé¢Á¥¢Ê∑±Â∫¶: ${difficulties[currentDifficulty].depth}ÊâãÂÖà\n\nÊñ∞„Åó„ÅÑ„Ç≤„Éº„É†„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ`
            );
        }

        function resetStats() {
            if (confirm('ÂãùÂà©Ë®òÈå≤„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü')) {
                wins = 0;
                localStorage.removeItem('ultimateOthelloWins');
                updateWins();
            }
        }

        function showMessage(title, text) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('game-message').style.display = 'flex';
        }

        function hideMessage() {
            document.getElementById('game-message').style.display = 'none';
        }

        // „Çø„ÉÉ„ÉÅÂØæÂøú
        document.addEventListener('touchstart', function() {
            if (SoundSystem.context && SoundSystem.context.state === 'suspended') {
                SoundSystem.context.resume();
            }
        }, { once: true });

        // „Ç≤„Éº„É†ÈñãÂßã
        init();
    </script>
</body>
</html>