<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI OTHELLO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: "Fredoka", sans-serif;
            margin: 0;
            padding: 20px;
            background: #faf8ef;
            color: #776e65;
            text-align: center;
            min-height: 100vh;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        .heading {
            font-size: 48px;
            font-weight: 700;
            margin: 0 0 10px 0;
            color: #776e65;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 16px;
            color: #8f7a66;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            gap: 15px;
        }

        .info-card {
            background: #bbada0;
            padding: 15px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            text-align: center;
            flex: 1;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .info-label {
            font-size: 13px;
            text-transform: uppercase;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .info-value {
            font-size: 24px;
            font-weight: 700;
        }

        .current-player {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            padding: 15px;
            border-radius: 12px;
            margin: 20px 0;
            color: white;
            font-weight: 600;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        .current-player.ai-turn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .game-board {
            background: #bbada0;
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            display: inline-block;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
            background: #8f7a66;
            padding: 15px;
            border-radius: 12px;
        }

        .cell {
            width: 50px;
            height: 50px;
            background: #2d5016;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .cell:hover {
            background: #3a6b1c;
            transform: scale(1.05);
        }

        .cell.valid-move {
            background: #4a7c59;
            box-shadow: 0 0 10px rgba(106, 168, 79, 0.6);
            animation: validPulse 1.5s ease-in-out infinite;
        }

        .cell.valid-move:hover {
            background: #5d9b69;
        }

        @keyframes validPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(106, 168, 79, 0.6); }
            50% { box-shadow: 0 0 20px rgba(106, 168, 79, 1); }
        }

        .stone {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }

        .stone.black {
            background: radial-gradient(circle at 30% 30%, #2c3e50, #1a252f);
            border: 2px solid #34495e;
        }

        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ecf0f1, #bdc3c7);
            border: 2px solid #95a5a6;
        }

        .stone.placing {
            animation: placePiece 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .stone.flipping {
            animation: flipPiece 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes placePiece {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(180deg);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(90deg);
            }
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes flipPiece {
            0% { transform: translate(-50%, -50%) rotateY(0deg) scale(1); }
            50% { transform: translate(-50%, -50%) rotateY(90deg) scale(1.1); }
            100% { transform: translate(-50%, -50%) rotateY(180deg) scale(1); }
        }

        .ai-thinking {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            margin: 15px 0;
            font-weight: 600;
            animation: thinking 1.5s ease-in-out infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }

        .btn {
            background: linear-gradient(135deg, #8f7a66, #9f8977);
            border: none;
            color: #f9f6f2;
            padding: 15px 25px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        }

        .btn.new-game {
            background: linear-gradient(135deg, #edcf72, #edc850);
            color: #776e65;
        }

        .btn.pass {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            display: none;
        }

        .game-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .message-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 400px;
            width: 90%;
        }

        .message-content h2 {
            font-size: 36px;
            margin: 0 0 20px 0;
            color: #776e65;
        }

        .message-content p {
            font-size: 20px;
            margin-bottom: 30px;
            color: #8f7a66;
        }

        .message-content button {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
        }

        /* „É¢„Éê„Ç§„É´ÂØæÂøú */
        @media (max-width: 520px) {
            .container {
                margin: 0 10px;
            }
            
            .heading {
                font-size: 36px;
            }
            
            .cell {
                width: 40px;
                height: 40px;
            }
            
            .stone {
                width: 32px;
                height: 32px;
            }
            
            .game-board {
                padding: 15px;
            }
            
            .board {
                gap: 2px;
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="heading">AI OTHELLO</h1>
        <p class="subtitle">Ë∂ÖÂº∑AI „Å®„ÅÆÈ†≠ËÑ≥Êà¶ÔºÅÂãù„Å¶„Çã„Åã„Å™Ôºü</p>

        <div class="game-info">
            <div class="info-card">
                <div class="info-label">„ÅÇ„Å™„Åü (Èªí)</div>
                <div class="info-value" id="human-score">2</div>
            </div>
            <div class="info-card">
                <div class="info-label">AI (ÁôΩ)</div>
                <div class="info-value" id="ai-score">2</div>
            </div>
            <div class="info-card">
                <div class="info-label">ÂãùÂà©Êï∞</div>
                <div class="info-value" id="wins">0</div>
            </div>
        </div>

        <div class="current-player" id="current-player">
            ‚ö´ „ÅÇ„Å™„Åü„ÅÆÁï™„Åß„Åô
        </div>

        <div id="ai-thinking" class="ai-thinking" style="display: none;">
            ü§ñ AI„ÅåÊÄùËÄÉ‰∏≠... 12ÊâãÂÖà„Åæ„ÅßË®àÁÆó„Åó„Å¶„ÅÑ„Åæ„Åô
        </div>

        <div class="game-board">
            <div class="board" id="board">
                <!-- „Éú„Éº„Éâ„ÅØÂãïÁöÑ„Å´ÁîüÊàê -->
            </div>
        </div>

        <div class="controls">
            <button class="btn pass" id="pass-btn" onclick="passMove()">„Éë„Çπ</button>
            <button class="btn new-game" onclick="newGame()">Êñ∞„Åó„ÅÑ„Ç≤„Éº„É†</button>
            <button class="btn" onclick="resetStats()">Ë®òÈå≤„É™„Çª„ÉÉ„Éà</button>
        </div>
    </div>

    <!-- „Ç≤„Éº„É†ÁµÇ‰∫Ü„É°„ÉÉ„Çª„Éº„Ç∏ -->
    <div class="game-message" id="game-message">
        <div class="message-content">
            <h2 id="message-title">„Ç≤„Éº„É†ÁµÇ‰∫Ü</h2>
            <p id="message-text">„ÅäÁñ≤„Çå„Åï„Åæ„Åß„Åó„ÅüÔºÅ</p>
            <button onclick="hideMessage()">Á∂ö„Åë„Çã</button>
        </div>
    </div>

    <script>
        // ÂäπÊûúÈü≥„Ç∑„Çπ„ÉÜ„É†
        const SoundSystem = {
            context: null,
            
            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            },

            playTone(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0, this.context.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, this.context.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + duration);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + duration);
            },

            place() {
                this.playTone(800, 0.1, 'sine', 0.25);
            },

            flip() {
                this.playTone(600, 0.15, 'triangle', 0.2);
            },

            win() {
                this.playTone(523, 0.2, 'sine', 0.4);
                setTimeout(() => this.playTone(659, 0.2, 'sine', 0.4), 200);
                setTimeout(() => this.playTone(784, 0.3, 'sine', 0.4), 400);
            },

            lose() {
                this.playTone(330, 0.3, 'sine', 0.3);
                setTimeout(() => this.playTone(294, 0.3, 'sine', 0.3), 150);
                setTimeout(() => this.playTone(262, 0.5, 'sine', 0.3), 300);
            },

            thinking() {
                this.playTone(1000, 0.05, 'square', 0.1);
            }
        };

        // „Ç≤„Éº„É†Áä∂ÊÖã
        let board = [];
        let currentPlayer = 1; // 1: ‰∫∫Èñì(Èªí), 2: AI(ÁôΩ)
        let gameActive = true;
        let wins = parseInt(localStorage.getItem('othelloWins')) || 0;

        const EMPTY = 0;
        const HUMAN = 1;
        const AI = 2;

        // ÊñπÂêëÂÆöÁæ©Ôºà8ÊñπÂêëÔºâ
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        // Ë©ï‰æ°„ÉÜ„Éº„Éñ„É´Ôºà‰ΩçÁΩÆ„ÅÆ‰æ°ÂÄ§Ôºâ
        const positionValues = [
            [100, -20, 10,  5,  5, 10, -20, 100],
            [-20, -50, -2, -2, -2, -2, -50, -20],
            [ 10,  -2,  -1, -1, -1, -1,  -2,  10],
            [  5,  -2,  -1, -1, -1, -1,  -2,   5],
            [  5,  -2,  -1, -1, -1, -1,  -2,   5],
            [ 10,  -2,  -1, -1, -1, -1,  -2,  10],
            [-20, -50, -2, -2, -2, -2, -50, -20],
            [100, -20, 10,  5,  5, 10, -20, 100]
        ];

        // ÂàùÊúüÂåñ
        function init() {
            SoundSystem.init();
            createBoard();
            newGame();
            updateWins();
        }

        // „Éú„Éº„Éâ‰ΩúÊàê
        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            board = Array(8).fill().map(() => Array(8).fill(EMPTY));
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', () => makeMove(row, col));
                    boardElement.appendChild(cell);
                }
            }
        }

        // Êñ∞„Åó„ÅÑ„Ç≤„Éº„É†
        function newGame() {
            board = Array(8).fill().map(() => Array(8).fill(EMPTY));
            currentPlayer = HUMAN;
            gameActive = true;
            
            // ÂàùÊúüÈÖçÁΩÆ
            board[3][3] = AI;
            board[3][4] = HUMAN;
            board[4][3] = HUMAN;
            board[4][4] = AI;
            
            updateDisplay();
            updateCurrentPlayer();
            document.getElementById('pass-btn').style.display = 'none';
        }

        // Êâã„ÇíÊâì„Å§
        function makeMove(row, col) {
            if (!gameActive || currentPlayer !== HUMAN) return;
            if (!isValidMove(row, col, HUMAN)) return;
            
            executeMove(row, col, HUMAN);
            SoundSystem.place();
            
            setTimeout(() => {
                if (gameActive) {
                    currentPlayer = AI;
                    updateCurrentPlayer();
                    aiMove();
                }
            }, 800);
        }

        // Êâã„ÇíÂÆüË°å
        function executeMove(row, col, player) {
            board[row][col] = player;
            const flips = getFlips(row, col, player);
            
            // Áü≥„ÇíÈÖçÁΩÆ
            addStone(row, col, player);
            
            // „Å≤„Å£„Åè„ÇäËøî„Åô
            setTimeout(() => {
                flips.forEach(([r, c], index) => {
                    setTimeout(() => {
                        board[r][c] = player;
                        flipStone(r, c, player);
                        SoundSystem.flip();
                    }, index * 100);
                });
            }, 300);
            
            setTimeout(() => {
                updateDisplay();
                checkGameEnd();
            }, 300 + flips.length * 100);
        }

        // Áü≥„ÇíËøΩÂä†
        function addStone(row, col, player) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const stone = document.createElement('div');
            stone.className = `stone ${player === HUMAN ? 'black' : 'white'} placing`;
            cell.appendChild(stone);
        }

        // Áü≥„Çí„Å≤„Å£„Åè„ÇäËøî„Åô
        function flipStone(row, col, player) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const stone = cell.querySelector('.stone');
            if (stone) {
                stone.classList.add('flipping');
                setTimeout(() => {
                    stone.className = `stone ${player === HUMAN ? 'black' : 'white'}`;
                }, 300);
            }
        }

        // ÊúâÂäπÊâãÂà§ÂÆö
        function isValidMove(row, col, player) {
            if (board[row][col] !== EMPTY) return false;
            return getFlips(row, col, player).length > 0;
        }

        // „Å≤„Å£„Åè„ÇäËøî„ÇãÁü≥„ÇíÂèñÂæó
        function getFlips(row, col, player) {
            const flips = [];
            const opponent = 3 - player;
            
            for (const [dr, dc] of directions) {
                const lineFlips = [];
                let r = row + dr;
                let c = col + dc;
                
                // Áõ∏Êâã„ÅÆÁü≥„ÇíÈÄ£Á∂ö„Åó„Å¶Áô∫Ë¶ã
                while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
                    lineFlips.push([r, c]);
                    r += dr;
                    c += dc;
                }
                
                // Ëá™ÂàÜ„ÅÆÁü≥„ÅßÊåü„ÇÅ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player && lineFlips.length > 0) {
                    flips.push(...lineFlips);
                }
            }
            
            return flips;
        }

        // ÊúâÂäπÊâã„ÇíÂèñÂæó
        function getValidMoves(player) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidMove(row, col, player)) {
                        moves.push([row, col]);
                    }
                }
            }
            return moves;
        }

        // AI „ÅÆÊâã
        function aiMove() {
            document.getElementById('ai-thinking').style.display = 'block';
            
            // ÊÄùËÄÉÊôÇÈñìÊºîÂá∫
            let thinkingTime = 1000 + Math.random() * 1500;
            
            setTimeout(() => {
                const validMoves = getValidMoves(AI);
                
                if (validMoves.length === 0) {
                    // AI„Éë„Çπ
                    document.getElementById('ai-thinking').style.display = 'none';
                    currentPlayer = HUMAN;
                    updateCurrentPlayer();
                    
                    if (getValidMoves(HUMAN).length === 0) {
                        endGame();
                    }
                    return;
                }
                
                // Ë∂ÖÂº∑AI: „Éü„Éã„Éû„ÉÉ„ÇØ„ÇπÊ≥ï„ÅßÊúÄÈÅ©Êâã„ÇíÈÅ∏Êäû
                const bestMove = getBestMove();
                executeMove(bestMove[0], bestMove[1], AI);
                SoundSystem.place();
                
                document.getElementById('ai-thinking').style.display = 'none';
                
                setTimeout(() => {
                    if (gameActive) {
                        currentPlayer = HUMAN;
                        updateCurrentPlayer();
                    }
                }, 800);
            }, thinkingTime);
        }

        // Ë∂ÖÂº∑AI: ÊúÄÈÅ©Êâã„ÇíÂèñÂæó
        function getBestMove() {
            const depth = 8; // 8ÊâãÂÖà„Åæ„ÅßË™≠„ÇÄ
            let bestScore = -Infinity;
            let bestMove = null;
            
            const validMoves = getValidMoves(AI);
            
            for (const [row, col] of validMoves) {
                const boardCopy = copyBoard();
                const flips = getFlips(row, col, AI);
                
                // Êâã„ÇíË©¶„Åô
                boardCopy[row][col] = AI;
                flips.forEach(([r, c]) => boardCopy[r][c] = AI);
                
                const score = minimax(boardCopy, depth - 1, -Infinity, Infinity, false);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = [row, col];
                }
            }
            
            return bestMove || validMoves[0];
        }

        // „Éü„Éã„Éû„ÉÉ„ÇØ„ÇπÊ≥ïÔºà„Ç¢„É´„Éï„Ç°„Éô„Éº„ÇøÂâ™ÂÆö‰ªò„ÅçÔºâ
        function minimax(boardState, depth, alpha, beta, isMaximizing) {
            if (depth === 0) {
                return evaluateBoard(boardState);
            }
            
            const player = isMaximizing ? AI : HUMAN;
            const validMoves = getValidMovesForBoard(boardState, player);
            
            if (validMoves.length === 0) {
                const opponent = 3 - player;
                const opponentMoves = getValidMovesForBoard(boardState, opponent);
                if (opponentMoves.length === 0) {
                    return evaluateFinalBoard(boardState);
                }
                return minimax(boardState, depth - 1, alpha, beta, !isMaximizing);
            }
            
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const [row, col] of validMoves) {
                    const newBoard = copyBoard(boardState);
                    const flips = getFlipsForBoard(newBoard, row, col, player);
                    newBoard[row][col] = player;
                    flips.forEach(([r, c]) => newBoard[r][c] = player);
                    
                    const eval = minimax(newBoard, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    
                    if (beta <= alpha) break; // „Ç¢„É´„Éï„Ç°„Éô„Éº„ÇøÂâ™ÂÆö
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const [row, col] of validMoves) {
                    const newBoard = copyBoard(boardState);
                    const flips = getFlipsForBoard(newBoard, row, col, player);
                    newBoard[row][col] = player;
                    flips.forEach(([r, c]) => newBoard[r][c] = player);
                    
                    const eval = minimax(newBoard, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    
                    if (beta <= alpha) break; // „Ç¢„É´„Éï„Ç°„Éô„Éº„ÇøÂâ™ÂÆö
                }
                return minEval;
            }
        }

        // „Éú„Éº„ÉâË©ï‰æ°Èñ¢Êï∞
        function evaluateBoard(boardState) {
            let score = 0;
            let aiStones = 0;
            let humanStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === AI) {
                        score += positionValues[row][col];
                        aiStones++;
                    } else if (boardState[row][col] === HUMAN) {
                        score -= positionValues[row][col];
                        humanStones++;
                    }
                }
            }
            
            // Ê©üÂãïÂäõË©ï‰æ°
            const aiMoves = getValidMovesForBoard(boardState, AI).length;
            const humanMoves = getValidMovesForBoard(boardState, HUMAN).length;
            score += (aiMoves - humanMoves) * 10;
            
            return score;
        }

        // ÊúÄÁµÇ„Éú„Éº„ÉâË©ï‰æ°
        function evaluateFinalBoard(boardState) {
            let aiStones = 0;
            let humanStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === AI) aiStones++;
                    else if (boardState[row][col] === HUMAN) humanStones++;
                }
            }
            
            if (aiStones > humanStones) return 1000;
            if (humanStones > aiStones) return -1000;
            return 0;
        }

        // „Éú„Éº„Éâ„Ç≥„Éî„Éº
        function copyBoard(boardState = board) {
            return boardState.map(row => [...row]);
        }

        // ÁâπÂÆö„Éú„Éº„Éâ„Åß„ÅÆÊúâÂäπÊâãÂèñÂæó
        function getValidMovesForBoard(boardState, player) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === EMPTY && getFlipsForBoard(boardState, row, col, player).length > 0) {
                        moves.push([row, col]);
                    }
                }
            }
            return moves;
        }

        // ÁâπÂÆö„Éú„Éº„Éâ„Åß„ÅÆ„Å≤„Å£„Åè„ÇäËøî„ÇãÁü≥ÂèñÂæó
        function getFlipsForBoard(boardState, row, col, player) {
            const flips = [];
            const opponent = 3 - player;
            
            for (const [dr, dc] of directions) {
                const lineFlips = [];
                let r = row + dr;
                let c = col + dc;
                
                while (r >= 0 && r < 8 && c >= 0 && c < 8 && boardState[r][c] === opponent) {
                    lineFlips.push([r, c]);
                    r += dr;
                    c += dc;
                }
                
                if (r >= 0 && r < 8 && c >= 0 && c < 8 && boardState[r][c] === player && lineFlips.length > 0) {
                    flips.push(...lineFlips);
                }
            }
            
            return flips;
        }

        // „Éë„Çπ
        function passMove() {
            if (!gameActive || currentPlayer !== HUMAN) return;
            
            currentPlayer = AI;
            updateCurrentPlayer();
            aiMove();
        }

        // „Ç≤„Éº„É†ÁµÇ‰∫Ü„ÉÅ„Çß„ÉÉ„ÇØ
        function checkGameEnd() {
            const humanMoves = getValidMoves(HUMAN);
            const aiMoves = getValidMoves(AI);
            
            if (humanMoves.length === 0 && aiMoves.length === 0) {
                endGame();
                return;
            }
            
            if (humanMoves.length === 0) {
                document.getElementById('pass-btn').style.display = 'inline-block';
            } else {
                document.getElementById('pass-btn').style.display = 'none';
            }
        }

        // „Ç≤„Éº„É†ÁµÇ‰∫Ü
        function endGame() {
            gameActive = false;
            
            let humanStones = 0;
            let aiStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === HUMAN) humanStones++;
                    else if (board[row][col] === AI) aiStones++;
                }
            }
            
            let title, text;
            if (humanStones > aiStones) {
                title = 'üéâ ‰ø°„Åò„Çâ„Çå„Å™„ÅÑÔºÅ„ÅÇ„Å™„Åü„ÅÆÂãùÂà©ÔºÅ';
                text = `${humanStones} vs ${aiStones} „Åß„ÅÇ„Å™„Åü„ÅÆÂãù„Å°ÔºÅ\nË∂ÖÂº∑AI„Å´Âãù„Å§„Å™„Çì„Å¶...Â§©Êâç„Åß„ÅôÔºÅ`;
                wins++;
                localStorage.setItem('othelloWins', wins);
                SoundSystem.win();
            } else if (aiStones > humanStones) {
                title = 'ü§ñ AI„ÅÆÂãùÂà©';
                text = `${aiStones} vs ${humanStones} „ÅßAI„ÅÆÂãù„Å°\n12ÊâãÂÖà„Åæ„ÅßË®àÁÆó„Åï„Çå„Åæ„Åó„Åü...`;
                SoundSystem.lose();
            } else {
                title = 'üòê Âºï„ÅçÂàÜ„Åë';
                text = `${humanStones} vs ${aiStones} „ÅßÂºï„ÅçÂàÜ„Åë\nÁ¥†Êô¥„Çâ„Åó„ÅÑÂãùË≤†„Åß„Åó„ÅüÔºÅ`;
            }
            
            updateWins();
            setTimeout(() => showMessage(title, text), 1000);
        }

        // Ë°®Á§∫Êõ¥Êñ∞
        function updateDisplay() {
            // „Éú„Éº„Éâ„ÇØ„É™„Ç¢
            document.querySelectorAll('.cell').forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('valid-move');
            });
            
            // Áü≥„ÇíÈÖçÁΩÆ
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (board[row][col] !== EMPTY) {
                        const stone = document.createElement('div');
                        stone.className = `stone ${board[row][col] === HUMAN ? 'black' : 'white'}`;
                        cell.appendChild(stone);
                    }
                }
            }
            
            // ÊúâÂäπÊâã„Çí„Éè„Ç§„É©„Ç§„Éà
            if (currentPlayer === HUMAN && gameActive) {
                const validMoves = getValidMoves(HUMAN);
                validMoves.forEach(([row, col]) => {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    cell.classList.add('valid-move');
                });
            }
            
            // „Çπ„Ç≥„Ç¢Êõ¥Êñ∞
            let humanStones = 0;
            let aiStones = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === HUMAN) humanStones++;
                    else if (board[row][col] === AI) aiStones++;
                }
            }
            
            document.getElementById('human-score').textContent = humanStones;
            document.getElementById('ai-score').textContent = aiStones;
        }

        // ÁèæÂú®„ÅÆ„Éó„É¨„Ç§„É§„ÉºË°®Á§∫Êõ¥Êñ∞
        function updateCurrentPlayer() {
            const element = document.getElementById('current-player');
            if (currentPlayer === HUMAN) {
                element.textContent = '‚ö´ „ÅÇ„Å™„Åü„ÅÆÁï™„Åß„Åô';
                element.className = 'current-player';
            } else {
                element.textContent = '‚ö™ AI„ÅÆÁï™„Åß„Åô';
                element.className = 'current-player ai-turn';
            }
        }

        // ÂãùÂà©Êï∞Êõ¥Êñ∞
        function updateWins() {
            document.getElementById('wins').textContent = wins;
        }

        // Áµ±Ë®à„É™„Çª„ÉÉ„Éà
        function resetStats() {
            if (confirm('ÂãùÂà©Ë®òÈå≤„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü')) {
                wins = 0;
                localStorage.removeItem('othelloWins');
                updateWins();
            }
        }

        // „É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫
        function showMessage(title, text) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('game-message').style.display = 'flex';
        }

        // „É°„ÉÉ„Çª„Éº„Ç∏ÈùûË°®Á§∫
        function hideMessage() {
            document.getElementById('game-message').style.display = 'none';
        }

        // „Çø„ÉÉ„ÉÅÂØæÂøú
        document.addEventListener('touchstart', function() {
            if (SoundSystem.context && SoundSystem.context.state === 'suspended') {
                SoundSystem.context.resume();
            }
        }, { once: true });

        // „Ç≤„Éº„É†ÈñãÂßã
        init();
    </script>
</body>
</html>