<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ULTIMATE AI OTHELLO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: "Fredoka", sans-serif;
            margin: 0;
            padding: 15px;
            background: #faf8ef;
            color: #776e65;
            text-align: center;
            min-height: 100vh;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        .heading {
            font-size: 42px;
            font-weight: 700;
            margin: 0 0 15px 0;
            color: #776e65;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            letter-spacing: 2px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            gap: 8px;
        }

        .info-card {
            background: #bbada0;
            padding: 10px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            text-align: center;
            flex: 1;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .info-label {
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .info-value {
            font-size: 18px;
            font-weight: 700;
        }

        .ai-status {
            color: #8f7a66;
            padding: 10px 0;
            margin: 10px 0;
            font-weight: 500;
            font-size: 13px;
        }

        .current-player {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            padding: 12px;
            border-radius: 12px;
            margin: 15px 0;
            color: white;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        .current-player.ai-turn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .game-board {
            background: #bbada0;
            border-radius: 16px;
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            display: inline-block;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #8f7a66;
            padding: 12px;
            border-radius: 12px;
        }

        .cell {
            width: 45px;
            height: 45px;
            background: #2d5016;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .cell:hover {
            background: #3a6b1c;
            transform: scale(1.05);
        }

        .cell.valid-move {
            background: #4a7c59;
            box-shadow: 0 0 10px rgba(106, 168, 79, 0.6);
            animation: validPulse 1.5s ease-in-out infinite;
        }

        .cell.valid-move:hover {
            background: #5d9b69;
        }

        .cell.corner {
            background: #4a4a4a;
        }

        .cell.edge {
            background: #3a3a3a;
        }

        @keyframes validPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(106, 168, 79, 0.6); }
            50% { box-shadow: 0 0 20px rgba(106, 168, 79, 1); }
        }

        .stone {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }

        .stone.black {
            background: radial-gradient(circle at 30% 30%, #2c3e50, #1a252f);
            border: 2px solid #34495e;
        }

        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ecf0f1, #bdc3c7);
            border: 2px solid #95a5a6;
        }

        .stone.placing {
            animation: placePiece 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .stone.flipping {
            animation: flipPiece 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes placePiece {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(180deg);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(90deg);
            }
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes flipPiece {
            0% { transform: translate(-50%, -50%) rotateY(0deg) scale(1); }
            50% { transform: translate(-50%, -50%) rotateY(90deg) scale(1.1); }
            100% { transform: translate(-50%, -50%) rotateY(180deg) scale(1); }
        }

        .ai-thinking {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 12px 15px;
            border-radius: 12px;
            margin: 12px 0;
            font-weight: 600;
            animation: thinking 1.5s ease-in-out infinite;
            font-size: 13px;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #8f7a66, #9f8977);
            border: none;
            color: #f9f6f2;
            padding: 10px 16px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        }

        .btn.new-game {
            background: linear-gradient(135deg, #edcf72, #edc850);
            color: #776e65;
        }

        .btn.pass {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            display: none;
        }

        .btn.difficulty {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
        }

        .game-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .message-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 350px;
            width: 90%;
        }

        .message-content h2 {
            font-size: 28px;
            margin: 0 0 15px 0;
            color: #776e65;
        }

        .message-content p {
            font-size: 16px;
            margin-bottom: 25px;
            color: #8f7a66;
            line-height: 1.4;
        }

        .message-content button {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
        }

        /* モバイル対応 */
        @media (max-width: 520px) {
            .container {
                margin: 0 5px;
            }
            
            .heading {
                font-size: 32px;
                margin-bottom: 10px;
            }
            
            .cell {
                width: 38px;
                height: 38px;
            }
            
            .stone {
                width: 30px;
                height: 30px;
            }
            
            .game-board {
                padding: 12px;
            }
            
            .board {
                gap: 2px;
                padding: 10px;
            }

            .info-value {
                font-size: 16px;
            }

            .info-label {
                font-size: 10px;
            }

            .controls {
                gap: 8px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 12px;
            }

            .current-player {
                font-size: 14px;
                padding: 10px;
            }

            .ai-status {
                font-size: 12px;
            }

            .ai-thinking {
                font-size: 12px;
                padding: 10px 12px;
            }
        }

        @media (max-width: 400px) {
            .cell {
                width: 32px;
                height: 32px;
            }
            
            .stone {
                width: 26px;
                height: 26px;
            }

            .heading {
                font-size: 28px;
            }

            .game-info {
                gap: 6px;
            }

            .info-card {
                padding: 8px;
            }

            .info-value {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="heading">ULTIMATE AI</h1>

        <div class="game-info">
            <div class="info-card">
                <div class="info-label">あなた ⚫</div>
                <div class="info-value" id="human-score">2</div>
            </div>
            <div class="info-card">
                <div class="info-label">AI ⚪</div>
                <div class="info-value" id="ai-score">2</div>
            </div>
            <div class="info-card">
                <div class="info-label">勝利数</div>
                <div class="info-value" id="wins">0</div>
            </div>
            <div class="info-card">
                <div class="info-label">レベル</div>
                <div class="info-value" id="difficulty">神</div>
            </div>
        </div>

        <div class="ai-status" id="ai-status">
            🧠 AI状態: 待機中 | 探索深度: 自動調整 | 評価関数: Ultimate
        </div>

        <div class="current-player" id="current-player">
            ⚫ あなたの番です
        </div>

        <div id="ai-thinking" class="ai-thinking" style="display: none;">
            🤖 Ultimate AI 思考中...<br>
            <span id="thinking-detail">完璧手を計算中...</span>
        </div>

        <div class="game-board">
            <div class="board" id="board">
                <!-- ボードは動的に生成 -->
            </div>
        </div>

        <div class="controls">
            <button class="btn pass" id="pass-btn" onclick="passMove()">パス</button>
            <button class="btn new-game" onclick="newGame()">新ゲーム</button>
            <button class="btn difficulty" onclick="changeDifficulty()">難易度変更</button>
            <button class="btn" onclick="resetStats()">記録リセット</button>
        </div>
    </div>

    <!-- ゲーム終了メッセージ -->
    <div class="game-message" id="game-message">
        <div class="message-content">
            <h2 id="message-title">ゲーム終了</h2>
            <p id="message-text">お疲れさまでした！</p>
            <button onclick="hideMessage()">続ける</button>
        </div>
    </div>

    <script>
        // 効果音システム
        const SoundSystem = {
            context: null,
            
            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                }
            },

            playTone(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0, this.context.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, this.context.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + duration);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + duration);
            },

            place() { this.playTone(800, 0.1, 'sine', 0.25); },
            flip() { this.playTone(600, 0.15, 'triangle', 0.2); },
            win() {
                this.playTone(523, 0.2, 'sine', 0.4);
                setTimeout(() => this.playTone(659, 0.2, 'sine', 0.4), 200);
                setTimeout(() => this.playTone(784, 0.3, 'sine', 0.4), 400);
            },
            lose() {
                this.playTone(330, 0.3, 'sine', 0.3);
                setTimeout(() => this.playTone(294, 0.3, 'sine', 0.3), 150);
                setTimeout(() => this.playTone(262, 0.5, 'sine', 0.3), 300);
            }
        };

        // ゲーム定数
        const EMPTY = 0;
        const HUMAN = 1;
        const AI = 2;

        // 方向定義（8方向）
        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        // 難易度設定
        const difficulties = {
            easy: { name: '初級', depth: 4, description: '初心者向け' },
            normal: { name: '中級', depth: 6, description: '標準的な強さ' },
            hard: { name: '上級', depth: 8, description: '手強い相手' },
            expert: { name: '最強', depth: 10, description: '専門家レベル' },
            ultimate: { name: '神', depth: 12, description: '究極のAI' }
        };

        // ゲーム状態
        let board = [];
        let currentPlayer = HUMAN;
        let gameActive = true;
        let wins = parseInt(localStorage.getItem('ultimateOthelloWins')) || 0;
        let currentDifficulty = localStorage.getItem('othelloDifficulty') || 'ultimate';
        let transpositionTable = new Map();
        let nodesEvaluated = 0;

        // 究極の位置評価テーブル
        const ultimatePositionValues = [
            [1000, -300,  100,   80,   80,  100, -300, 1000],
            [-300, -500,  -50,  -50,  -50,  -50, -500, -300],
            [ 100,  -50,   50,   10,   10,   50,  -50,  100],
            [  80,  -50,   10,    5,    5,   10,  -50,   80],
            [  80,  -50,   10,    5,    5,   10,  -50,   80],
            [ 100,  -50,   50,   10,   10,   50,  -50,  100],
            [-300, -500,  -50,  -50,  -50,  -50, -500, -300],
            [1000, -300,  100,   80,   80,  100, -300, 1000]
        ];

        // エッジとコーナーの定義
        const corners = [[0,0], [0,7], [7,0], [7,7]];
        const edges = [];
        for (let i = 0; i < 8; i++) {
            edges.push([0, i], [7, i], [i, 0], [i, 7]);
        }

        // 危険なX位置（コーナー隣接）
        const xSquares = [[1,1], [1,6], [6,1], [6,6]];

        // 初期化
        function init() {
            SoundSystem.init();
            createBoard();
            newGame();
            updateWins();
            updateDifficultyDisplay();
        }

        // ボード作成
        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            board = Array(8).fill().map(() => Array(8).fill(EMPTY));
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    // 特別な位置のスタイル
                    if (corners.some(([r, c]) => r === row && c === col)) {
                        cell.classList.add('corner');
                    } else if (edges.some(([r, c]) => r === row && c === col)) {
                        cell.classList.add('edge');
                    }
                    
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', () => makeMove(row, col));
                    boardElement.appendChild(cell);
                }
            }
        }

        // 新しいゲーム
        function newGame() {
            board = Array(8).fill().map(() => Array(8).fill(EMPTY));
            currentPlayer = HUMAN;
            gameActive = true;
            transpositionTable.clear();
            
            // 初期配置
            board[3][3] = AI;
            board[3][4] = HUMAN;
            board[4][3] = HUMAN;
            board[4][4] = AI;
            
            updateDisplay();
            updateCurrentPlayer();
            updateAIStatus('待機中', 0, 'Ultimate');
            document.getElementById('pass-btn').style.display = 'none';
        }

        // プレイヤーの手
        function makeMove(row, col) {
            if (!gameActive || currentPlayer !== HUMAN) return;
            if (!isValidMove(row, col, HUMAN)) return;
            
            executeMove(row, col, HUMAN);
            SoundSystem.place();
            
            setTimeout(() => {
                if (gameActive) {
                    currentPlayer = AI;
                    updateCurrentPlayer();
                    aiMove();
                }
            }, 800);
        }

        // 手を実行
        function executeMove(row, col, player) {
            board[row][col] = player;
            const flips = getFlips(row, col, player);
            
            addStone(row, col, player);
            
            setTimeout(() => {
                flips.forEach(([r, c], index) => {
                    setTimeout(() => {
                        board[r][c] = player;
                        flipStone(r, c, player);
                        SoundSystem.flip();
                    }, index * 100);
                });
            }, 300);
            
            setTimeout(() => {
                updateDisplay();
                checkGameEnd();
            }, 300 + flips.length * 100);
        }

        // AI の手
        function aiMove() {
            document.getElementById('ai-thinking').style.display = 'block';
            updateThinkingDetail('AI思考開始...');
            
            const startTime = Date.now();
            let thinkingTime = 1500 + Math.random() * 2000;
            
            setTimeout(() => {
                const validMoves = getValidMoves(AI);
                
                if (validMoves.length === 0) {
                    document.getElementById('ai-thinking').style.display = 'none';
                    currentPlayer = HUMAN;
                    updateCurrentPlayer();
                    
                    if (getValidMoves(HUMAN).length === 0) {
                        endGame();
                    }
                    return;
                }
                
                nodesEvaluated = 0;
                const bestMove = getUltimateBestMove();
                const endTime = Date.now();
                
                updateAIStatus('完了', nodesEvaluated, `${endTime - startTime}ms`);
                
                executeMove(bestMove[0], bestMove[1], AI);
                SoundSystem.place();
                
                document.getElementById('ai-thinking').style.display = 'none';
                
                setTimeout(() => {
                    if (gameActive) {
                        currentPlayer = HUMAN;
                        updateCurrentPlayer();
                    }
                }, 800);
            }, thinkingTime);
        }

        // 究極のAI: 最適手を取得
        function getUltimateBestMove() {
            const gamePhase = getGamePhase();
            const depth = getOptimalDepth(gamePhase);
            
            updateThinkingDetail(`${gamePhase}戦略 | 深度${depth}で完璧手計算中...`);
            
            let bestScore = -Infinity;
            let bestMove = null;
            const validMoves = getValidMoves(AI);
            
            // 手を重要度順にソート
            const sortedMoves = sortMovesByPriority(validMoves, AI);
            
            for (const [row, col] of sortedMoves) {
                const boardCopy = copyBoard();
                const flips = getFlips(row, col, AI);
                
                boardCopy[row][col] = AI;
                flips.forEach(([r, c]) => boardCopy[r][c] = AI);
                
                const score = ultimateMinimax(boardCopy, depth - 1, -Infinity, Infinity, false, gamePhase);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = [row, col];
                }
            }
            
            return bestMove || validMoves[0];
        }

        // 究極のミニマックス法
        function ultimateMinimax(boardState, depth, alpha, beta, isMaximizing, gamePhase) {
            nodesEvaluated++;
            
            // 終端条件
            if (depth === 0) {
                return ultimateEvaluateBoard(boardState, gamePhase);
            }
            
            // トランスポジションテーブルチェック
            const boardHash = getBoardHash(boardState);
            const tableKey = `${boardHash}_${depth}_${isMaximizing}`;
            if (transpositionTable.has(tableKey)) {
                return transpositionTable.get(tableKey);
            }
            
            const player = isMaximizing ? AI : HUMAN;
            const validMoves = getValidMovesForBoard(boardState, player);
            
            if (validMoves.length === 0) {
                const opponent = 3 - player;
                const opponentMoves = getValidMovesForBoard(boardState, opponent);
                if (opponentMoves.length === 0) {
                    const result = ultimateEvaluateFinalBoard(boardState);
                    transpositionTable.set(tableKey, result);
                    return result;
                }
                const result = ultimateMinimax(boardState, depth - 1, alpha, beta, !isMaximizing, gamePhase);
                transpositionTable.set(tableKey, result);
                return result;
            }
            
            // 手をソート
            const sortedMoves = sortMovesByPriority(validMoves, player);
            
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const [row, col] of sortedMoves) {
                    const newBoard = copyBoard(boardState);
                    const flips = getFlipsForBoard(newBoard, row, col, player);
                    newBoard[row][col] = player;
                    flips.forEach(([r, c]) => newBoard[r][c] = player);
                    
                    const eval = ultimateMinimax(newBoard, depth - 1, alpha, beta, false, gamePhase);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    
                    if (beta <= alpha) break;
                }
                transpositionTable.set(tableKey, maxEval);
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const [row, col] of sortedMoves) {
                    const newBoard = copyBoard(boardState);
                    const flips = getFlipsForBoard(newBoard, row, col, player);
                    newBoard[row][col] = player;
                    flips.forEach(([r, c]) => newBoard[r][c] = player);
                    
                    const eval = ultimateMinimax(newBoard, depth - 1, alpha, beta, true, gamePhase);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    
                    if (beta <= alpha) break;
                }
                transpositionTable.set(tableKey, minEval);
                return minEval;
            }
        }

        // 究極のボード評価関数
        function ultimateEvaluateBoard(boardState, gamePhase) {
            let score = 0;
            
            // 基本的な位置評価
            score += evaluatePositions(boardState);
            
            // コーナー制御評価
            score += evaluateCorners(boardState) * 500;
            
            // エッジ制御評価
            score += evaluateEdges(boardState) * 100;
            
            // 機動力評価
            score += evaluateMobility(boardState, gamePhase);
            
            // 安定性評価
            score += evaluateStability(boardState) * 200;
            
            // ゲーム段階別特別評価
            if (gamePhase === '序盤') {
                score += evaluateOpeningStrategy(boardState);
            } else if (gamePhase === '終盤') {
                score += evaluateEndgameStrategy(boardState);
            }
            
            // パリティ評価（終盤重要）
            if (gamePhase === '終盤') {
                score += evaluateParity(boardState) * 50;
            }
            
            return score;
        }

        // 位置評価
        function evaluatePositions(boardState) {
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === AI) {
                        score += ultimatePositionValues[row][col];
                    } else if (boardState[row][col] === HUMAN) {
                        score -= ultimatePositionValues[row][col];
                    }
                }
            }
            return score;
        }

        // コーナー制御評価
        function evaluateCorners(boardState) {
            let score = 0;
            for (const [row, col] of corners) {
                if (boardState[row][col] === AI) score += 1;
                else if (boardState[row][col] === HUMAN) score -= 1;
            }
            return score;
        }

        // エッジ制御評価
        function evaluateEdges(boardState) {
            let score = 0;
            for (const [row, col] of edges) {
                if (boardState[row][col] === AI) score += 1;
                else if (boardState[row][col] === HUMAN) score -= 1;
            }
            return score;
        }

        // 機動力評価
        function evaluateMobility(boardState, gamePhase) {
            const aiMoves = getValidMovesForBoard(boardState, AI).length;
            const humanMoves = getValidMovesForBoard(boardState, HUMAN).length;
            
            const mobilityWeight = gamePhase === '序盤' ? 50 : gamePhase === '中盤' ? 30 : 10;
            return (aiMoves - humanMoves) * mobilityWeight;
        }

        // 安定性評価（確定石）
        function evaluateStability(boardState) {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] !== EMPTY) {
                        const stability = calculateStability(boardState, row, col);
                        if (boardState[row][col] === AI) {
                            score += stability;
                        } else {
                            score -= stability;
                        }
                    }
                }
            }
            
            return score;
        }

        // 安定性計算
        function calculateStability(boardState, row, col) {
            const player = boardState[row][col];
            if (player === EMPTY) return 0;
            
            // コーナーは常に安定
            if (corners.some(([r, c]) => r === row && c === col)) {
                return 10;
            }
            
            let stability = 0;
            
            // 各方向の安定性をチェック
            for (const [dr, dc] of directions) {
                if (isDirectionStable(boardState, row, col, dr, dc, player)) {
                    stability += 1;
                }
            }
            
            return stability;
        }

        // 方向の安定性チェック
        function isDirectionStable(boardState, row, col, dr, dc, player) {
            // 一方向に安定している石があるかチェック
            let r1 = row + dr, c1 = col + dc;
            let r2 = row - dr, c2 = col - dc;
            
            let stable1 = false, stable2 = false;
            
            // 正方向チェック
            while (r1 >= 0 && r1 < 8 && c1 >= 0 && c1 < 8) {
                if (boardState[r1][c1] === player) {
                    if (corners.some(([r, c]) => r === r1 && c === c1)) {
                        stable1 = true;
                        break;
                    }
                } else {
                    break;
                }
                r1 += dr;
                c1 += dc;
            }
            
            // 負方向チェック
            while (r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
                if (boardState[r2][c2] === player) {
                    if (corners.some(([r, c]) => r === r2 && c === c2)) {
                        stable2 = true;
                        break;
                    }
                } else {
                    break;
                }
                r2 -= dr;
                c2 -= dc;
            }
            
            return stable1 || stable2;
        }

        // 序盤戦略評価
        function evaluateOpeningStrategy(boardState) {
            let score = 0;
            
            // X位置（コーナー隣接）の回避
            for (const [row, col] of xSquares) {
                if (boardState[row][col] === AI) score -= 200;
                else if (boardState[row][col] === HUMAN) score += 200;
            }
            
            // 中央制御
            const centerSquares = [[3,3], [3,4], [4,3], [4,4]];
            for (const [row, col] of centerSquares) {
                if (boardState[row][col] === AI) score += 20;
                else if (boardState[row][col] === HUMAN) score -= 20;
            }
            
            return score;
        }

        // 終盤戦略評価
        function evaluateEndgameStrategy(boardState) {
            let aiStones = 0;
            let humanStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === AI) aiStones++;
                    else if (boardState[row][col] === HUMAN) humanStones++;
                }
            }
            
            // 終盤では石数が重要
            return (aiStones - humanStones) * 100;
        }

        // パリティ評価
        function evaluateParity(boardState) {
            const emptyCount = countEmpty(boardState);
            return emptyCount % 2 === 0 ? 1 : -1; // 偶数なら有利
        }

        // 手の優先度ソート
        function sortMovesByPriority(moves, player) {
            return moves.sort((a, b) => {
                const scoreA = getMoveScore(a, player);
                const scoreB = getMoveScore(b, player);
                return scoreB - scoreA;
            });
        }

        // 手のスコア計算
        function getMoveScore(move, player) {
            const [row, col] = move;
            let score = 0;
            
            // 位置価値
            score += ultimatePositionValues[row][col];
            
            // コーナーなら最高点
            if (corners.some(([r, c]) => r === row && c === col)) {
                score += 10000;
            }
            
            // ひっくり返る石の数
            const flips = getFlipsForBoard(board, row, col, player);
            score += flips.length * 10;
            
            return score;
        }

        // ゲーム段階判定
        function getGamePhase() {
            const totalStones = countTotalStones();
            if (totalStones <= 20) return '序盤';
            if (totalStones >= 50) return '終盤';
            return '中盤';
        }

        // 最適深度取得
        function getOptimalDepth(gamePhase) {
            const baseDepth = difficulties[currentDifficulty].depth;
            const emptyCount = countEmpty();
            
            if (gamePhase === '終盤' && emptyCount <= 12) {
                return Math.min(emptyCount, baseDepth + 2);
            }
            
            return baseDepth;
        }

        // ユーティリティ関数
        function countTotalStones() {
            let count = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] !== EMPTY) count++;
                }
            }
            return count;
        }

        function countEmpty(boardState = board) {
            let count = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === EMPTY) count++;
                }
            }
            return count;
        }

        function getBoardHash(boardState) {
            return boardState.flat().join('');
        }

        // 基本ゲーム関数
        function isValidMove(row, col, player) {
            if (board[row][col] !== EMPTY) return false;
            return getFlips(row, col, player).length > 0;
        }

        function getFlips(row, col, player) {
            const flips = [];
            const opponent = 3 - player;
            
            for (const [dr, dc] of directions) {
                const lineFlips = [];
                let r = row + dr;
                let c = col + dc;
                
                while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
                    lineFlips.push([r, c]);
                    r += dr;
                    c += dc;
                }
                
                if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player && lineFlips.length > 0) {
                    flips.push(...lineFlips);
                }
            }
            
            return flips;
        }

        function getValidMoves(player) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidMove(row, col, player)) {
                        moves.push([row, col]);
                    }
                }
            }
            return moves;
        }

        function getValidMovesForBoard(boardState, player) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === EMPTY && getFlipsForBoard(boardState, row, col, player).length > 0) {
                        moves.push([row, col]);
                    }
                }
            }
            return moves;
        }

        function getFlipsForBoard(boardState, row, col, player) {
            const flips = [];
            const opponent = 3 - player;
            
            for (const [dr, dc] of directions) {
                const lineFlips = [];
                let r = row + dr;
                let c = col + dc;
                
                while (r >= 0 && r < 8 && c >= 0 && c < 8 && boardState[r][c] === opponent) {
                    lineFlips.push([r, c]);
                    r += dr;
                    c += dc;
                }
                
                if (r >= 0 && r < 8 && c >= 0 && c < 8 && boardState[r][c] === player && lineFlips.length > 0) {
                    flips.push(...lineFlips);
                }
            }
            
            return flips;
        }

        function copyBoard(boardState = board) {
            return boardState.map(row => [...row]);
        }

        function ultimateEvaluateFinalBoard(boardState) {
            let aiStones = 0;
            let humanStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === AI) aiStones++;
                    else if (boardState[row][col] === HUMAN) humanStones++;
                }
            }
            
            if (aiStones > humanStones) return 100000;
            if (humanStones > aiStones) return -100000;
            return 0;
        }

        // UI更新関数
        function addStone(row, col, player) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const stone = document.createElement('div');
            stone.className = `stone ${player === HUMAN ? 'black' : 'white'} placing`;
            cell.appendChild(stone);
        }

        function flipStone(row, col, player) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const stone = cell.querySelector('.stone');
            if (stone) {
                stone.classList.add('flipping');
                setTimeout(() => {
                    stone.className = `stone ${player === HUMAN ? 'black' : 'white'}`;
                }, 300);
            }
        }

        function updateDisplay() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.innerHTML = '';
                cell.classList.remove('valid-move');
            });
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (board[row][col] !== EMPTY) {
                        const stone = document.createElement('div');
                        stone.className = `stone ${board[row][col] === HUMAN ? 'black' : 'white'}`;
                        cell.appendChild(stone);
                    }
                }
            }
            
            if (currentPlayer === HUMAN && gameActive) {
                const validMoves = getValidMoves(HUMAN);
                validMoves.forEach(([row, col]) => {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    cell.classList.add('valid-move');
                });
            }
            
            let humanStones = 0;
            let aiStones = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === HUMAN) humanStones++;
                    else if (board[row][col] === AI) aiStones++;
                }
            }
            
            document.getElementById('human-score').textContent = humanStones;
            document.getElementById('ai-score').textContent = aiStones;
        }

        function updateCurrentPlayer() {
            const element = document.getElementById('current-player');
            if (currentPlayer === HUMAN) {
                element.textContent = '⚫ あなたの番です';
                element.className = 'current-player';
            } else {
                element.textContent = '⚪ Ultimate AIの番です';
                element.className = 'current-player ai-turn';
            }
        }

        function updateAIStatus(status, nodes, extra) {
            const element = document.getElementById('ai-status');
            element.innerHTML = `🧠 AI状態: ${status} | 探索ノード: ${nodes.toLocaleString()} | ${extra}`;
        }

        function updateThinkingDetail(text) {
            document.getElementById('thinking-detail').textContent = text;
        }

        function updateDifficultyDisplay() {
            document.getElementById('difficulty').textContent = difficulties[currentDifficulty].name;
        }

        function updateWins() {
            document.getElementById('wins').textContent = wins;
        }

        // ゲーム制御関数
        function passMove() {
            if (!gameActive || currentPlayer !== HUMAN) return;
            
            currentPlayer = AI;
            updateCurrentPlayer();
            aiMove();
        }

        function checkGameEnd() {
            const humanMoves = getValidMoves(HUMAN);
            const aiMoves = getValidMoves(AI);
            
            if (humanMoves.length === 0 && aiMoves.length === 0) {
                endGame();
                return;
            }
            
            if (humanMoves.length === 0) {
                document.getElementById('pass-btn').style.display = 'inline-block';
            } else {
                document.getElementById('pass-btn').style.display = 'none';
            }
        }

        function endGame() {
            gameActive = false;
            
            let humanStones = 0;
            let aiStones = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === HUMAN) humanStones++;
                    else if (board[row][col] === AI) aiStones++;
                }
            }
            
            let title, text;
            if (humanStones > aiStones) {
                title = '🏆 奇跡！Ultimate AIに勝利！';
                text = `${humanStones} vs ${aiStones} であなたの勝ち！\n\n世界最強レベルのAIに勝つなんて...\nあなたは真の天才です！\n\n${difficulties[currentDifficulty].description}に勝利しました！`;
                wins++;
                localStorage.setItem('ultimateOthelloWins', wins);
                SoundSystem.win();
            } else if (aiStones > humanStones) {
                title = '🤖 Ultimate AIの勝利';
                text = `${aiStones} vs ${humanStones} でAIの勝ち\n\n${getGamePhase()}まで${nodesEvaluated.toLocaleString()}手を解析\n究極のアルゴリズムに敗北...`;
                SoundSystem.lose();
            } else {
                title = '🤝 互角の勝負！';
                text = `${humanStones} vs ${aiStones} で引き分け\n\nUltimate AIと引き分けとは\n素晴らしい実力です！`;
            }
            
            updateWins();
            setTimeout(() => showMessage(title, text), 1000);
        }

        function changeDifficulty() {
            const keys = Object.keys(difficulties);
            const currentIndex = keys.indexOf(currentDifficulty);
            const nextIndex = (currentIndex + 1) % keys.length;
            currentDifficulty = keys[nextIndex];
            
            localStorage.setItem('othelloDifficulty', currentDifficulty);
            updateDifficultyDisplay();
            transpositionTable.clear();
            
            showMessage(
                `難易度変更: ${difficulties[currentDifficulty].name}`,
                `${difficulties[currentDifficulty].description}\n探索深度: ${difficulties[currentDifficulty].depth}手先\n\n新しいゲームを開始してください`
            );
        }

        function resetStats() {
            if (confirm('勝利記録をリセットしますか？')) {
                wins = 0;
                localStorage.removeItem('ultimateOthelloWins');
                updateWins();
            }
        }

        function showMessage(title, text) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('game-message').style.display = 'flex';
        }

        function hideMessage() {
            document.getElementById('game-message').style.display = 'none';
        }

        // タッチ対応
        document.addEventListener('touchstart', function() {
            if (SoundSystem.context && SoundSystem.context.state === 'suspended') {
                SoundSystem.context.resume();
            }
        }, { once: true });

        // ゲーム開始
        init();
    </script>
</body>
</html>